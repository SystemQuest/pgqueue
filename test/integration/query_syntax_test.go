package integration

import (
	"context"
	"strings"
	"testing"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/systemquest/pgqueue/pkg/db"
	"github.com/systemquest/pgqueue/pkg/queries"
	"github.com/systemquest/pgqueue/test/testutil"
)

// TestValidQuerySyntax validates SQL syntax for all QueryBuilder methods
// Migrated from Python PgQueuer's test_valid_query_syntax (Commit 55fd027)
//
// This test ensures that all SQL queries generated by QueryBuilder are syntactically valid.
// While we have functional tests that exercise these queries, this test specifically validates
// SQL syntax by attempting to EXPLAIN each query, which catches syntax errors without executing.
//
// Python PgQueuer uses this pattern to test both asyncpg and psycopg drivers.
// Since Go pgqueue only uses pgx driver, we test against PostgreSQL directly.
func TestValidQuerySyntax(t *testing.T) {
	testDB := testutil.SetupTestDB(t)
	if testDB == nil {
		t.Skip("PostgreSQL not available")
	}
	defer testDB.Close()

	ctx := context.Background()
	qb := queries.NewQueryBuilder()

	// List of all query generation methods that return parameterized SQL
	// These correspond to Python's QueryBuilder methods tested in commit 55fd027
	testCases := []struct {
		name        string
		queryFunc   func() string
		description string
	}{
		{
			name:        "EnqueueQuery",
			queryFunc:   qb.CreateEnqueueQuery,
			description: "INSERT INTO queue with priority, entrypoint, payload",
		},
		{
			name:        "EnqueueBatchQuery",
			queryFunc:   qb.CreateEnqueueBatchQuery,
			description: "Batch INSERT with unnest() for multiple jobs",
		},
		{
			name:        "DequeueQuery",
			queryFunc:   qb.CreateDequeueQuery,
			description: "SELECT ... FOR UPDATE SKIP LOCKED with batch size",
		},
		{
			name:        "CompleteJobQuery",
			queryFunc:   qb.CreateCompleteJobQuery,
			description: "DELETE and INSERT into statistics (single job)",
		},
		{
			name:        "BatchCompleteJobsQuery",
			queryFunc:   qb.CreateBatchCompleteJobsQuery,
			description: "Batch DELETE with ANY($1) and statistics aggregation",
		},
		{
			name:        "QueueSizeQuery",
			queryFunc:   qb.CreateQueueSizeQuery,
			description: "SELECT COUNT(*) grouped by priority, entrypoint, status",
		},
		{
			name:        "DeleteFromQueueQuery",
			queryFunc:   qb.CreateDeleteFromQueueQuery,
			description: "DELETE FROM queue with entrypoint filter",
		},
		{
			name:        "TruncateQueueQuery",
			queryFunc:   qb.CreateTruncateQueueQuery,
			description: "TRUNCATE TABLE for queue",
		},
		{
			name:        "LogStatisticsQuery",
			queryFunc:   qb.CreateLogStatisticsQuery,
			description: "SELECT statistics ordered by created DESC",
		},
		{
			name:        "DeleteFromLogQuery",
			queryFunc:   qb.CreateDeleteFromLogQuery,
			description: "DELETE FROM statistics with entrypoint filter",
		},
		{
			name:        "TruncateLogQuery",
			queryFunc:   qb.CreateTruncateLogQuery,
			description: "TRUNCATE TABLE for statistics",
		},
		{
			name:        "HasColumnQuery",
			queryFunc:   qb.CreateHasColumnQuery,
			description: "Check if column exists in table schema",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			query := tc.queryFunc()
			require.NotEmpty(t, query, "Query should not be empty")

			// Validate SQL syntax using EXPLAIN
			// This is similar to Python's approach of executing queries with missing parameters
			// EXPLAIN parses the SQL without executing it, catching syntax errors
			err := validateSQLSyntax(ctx, testDB, query)

			if err != nil {
				// Check if error is expected (missing parameters)
				if isExpectedParameterError(err) {
					// This is expected - the query is syntactically valid but missing parameters
					t.Logf("✓ Query syntax valid (missing parameters expected): %s", tc.description)
				} else {
					// Unexpected error - likely a syntax error
					t.Errorf("SQL syntax error in %s: %v\nQuery:\n%s", tc.name, err, query)
				}
			} else {
				// Query executed successfully (no parameters needed or defaults used)
				t.Logf("✓ Query syntax valid: %s", tc.description)
			}
		})
	}
}

// validateSQLSyntax attempts to validate SQL syntax by using EXPLAIN
// This catches syntax errors without executing the query
func validateSQLSyntax(ctx context.Context, testDB *db.DB, query string) error {
	// Try to EXPLAIN the query - this validates syntax
	// We use a simple heuristic: if it's a DDL statement (CREATE/DROP/ALTER),
	// we can't EXPLAIN it, so we skip validation
	if isDDLStatement(query) {
		// For DDL statements, we just verify the query is not empty
		// Full DDL validation would require executing against a test schema
		return nil
	}

	// For DML/SELECT statements, use EXPLAIN to validate syntax
	explainQuery := "EXPLAIN " + query
	_, err := testDB.Pool().Exec(ctx, explainQuery)
	return err
}

// isDDLStatement checks if the query is a DDL statement
func isDDLStatement(query string) bool {
	trimmed := strings.TrimSpace(strings.ToUpper(query))
	ddlKeywords := []string{"CREATE", "DROP", "ALTER", "TRUNCATE"}

	for _, keyword := range ddlKeywords {
		if strings.HasPrefix(trimmed, keyword) {
			return true
		}
	}
	return false
}

// isExpectedParameterError checks if the error is an expected parameter-related error
// This mirrors Python's approach of catching UndefinedParameterError and ProgrammingError
func isExpectedParameterError(err error) bool {
	if err == nil {
		return false
	}

	// Check for pgx parameter errors
	if pgErr, ok := err.(*pgconn.PgError); ok {
		// PostgreSQL error codes:
		// 42P02: undefined_parameter
		// 42601: syntax_error (but we check the message to distinguish)
		if pgErr.Code == "42P02" {
			// Undefined parameter - expected
			return true
		}

		// Check error message for common parameter-related issues
		errMsg := strings.ToLower(pgErr.Message)
		if strings.Contains(errMsg, "bind message supplies") ||
			strings.Contains(errMsg, "there is no parameter") ||
			strings.Contains(errMsg, "bind variable") ||
			strings.Contains(errMsg, "could not determine data type") {
			return true
		}
	}

	// Check error message string for parameter issues
	errMsg := strings.ToLower(err.Error())
	if strings.Contains(errMsg, "bind message supplies") ||
		strings.Contains(errMsg, "there is no parameter") ||
		strings.Contains(errMsg, "bind variable") ||
		strings.Contains(errMsg, "could not determine data type") {
		return true
	}

	return false
}

// TestQueryBuilderWithPrefix validates that queries work correctly with table prefixes
// This is a Go-specific enhancement to ensure prefix functionality doesn't break SQL syntax
func TestQueryBuilderWithPrefix(t *testing.T) {
	// Test with various prefixes
	prefixes := []string{"", "test_", "myapp_", "v2_"}

	for _, prefix := range prefixes {
		t.Run("prefix_"+prefix, func(t *testing.T) {
			qb := queries.NewQueryBuilderWithPrefix(prefix)

			// Verify table names include prefix
			if prefix != "" {
				assert.Contains(t, qb.Settings.QueueTable, prefix)
				assert.Contains(t, qb.Settings.StatisticsTable, prefix)
				assert.Contains(t, qb.Settings.QueueStatusType, prefix)
				assert.Contains(t, qb.Settings.StatisticsTableStatusType, prefix)
			}

			// Verify queries are generated correctly with prefix
			query := qb.CreateQueueSizeQuery()
			assert.NotEmpty(t, query)

			// Verify the query contains the prefixed table name
			expectedTable := prefix + "pgqueue_jobs"
			assert.Contains(t, query, expectedTable,
				"Query should contain prefixed table name '%s'", expectedTable)
		})
	}
}

// TestQueryBuilderConsistency validates that all query methods return non-empty strings
// This is a sanity check to ensure no query builder method is broken
func TestQueryBuilderConsistency(t *testing.T) {
	qb := queries.NewQueryBuilder()

	queryMethods := map[string]func() string{
		"InstallQuery":           qb.CreateInstallQuery,
		"UninstallQuery":         qb.CreateUninstallQuery,
		"EnqueueQuery":           qb.CreateEnqueueQuery,
		"EnqueueBatchQuery":      qb.CreateEnqueueBatchQuery,
		"DequeueQuery":           qb.CreateDequeueQuery,
		"CompleteJobQuery":       qb.CreateCompleteJobQuery,
		"BatchCompleteJobsQuery": qb.CreateBatchCompleteJobsQuery,
		"QueueSizeQuery":         qb.CreateQueueSizeQuery,
		"DeleteFromQueueQuery":   qb.CreateDeleteFromQueueQuery,
		"TruncateQueueQuery":     qb.CreateTruncateQueueQuery,
		"LogStatisticsQuery":     qb.CreateLogStatisticsQuery,
		"DeleteFromLogQuery":     qb.CreateDeleteFromLogQuery,
		"TruncateLogQuery":       qb.CreateTruncateLogQuery,
		"HasColumnQuery":         qb.CreateHasColumnQuery,
	}

	for name, method := range queryMethods {
		t.Run(name, func(t *testing.T) {
			query := method()
			assert.NotEmpty(t, query, "Query should not be empty")
			assert.Greater(t, len(query), 10, "Query should have substantial content")

			// Verify query contains expected SQL keywords
			upperQuery := strings.ToUpper(query)
			hasSQL := strings.Contains(upperQuery, "SELECT") ||
				strings.Contains(upperQuery, "INSERT") ||
				strings.Contains(upperQuery, "UPDATE") ||
				strings.Contains(upperQuery, "DELETE") ||
				strings.Contains(upperQuery, "CREATE") ||
				strings.Contains(upperQuery, "DROP") ||
				strings.Contains(upperQuery, "TRUNCATE")

			assert.True(t, hasSQL, "Query should contain SQL keywords")
		})
	}
}
